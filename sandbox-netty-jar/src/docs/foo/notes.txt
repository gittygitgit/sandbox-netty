Terms
	Session
		- A logical set of messages
		- There is typically only one session per day
		- It is possible to roll multiple sessions in a day (done in the event the previous session needs to be discarded for some reason)
				
	Rolling a new Session
		- Creating a new session container
	
	SessionStream
		- The real-time feed of session messages
		- Refers to messages just produced as opposed to rerequested.
		
	Rerequest	
		- A request for session messages already published to the stream
		- Entails loading previously persisted messages
		- After processing a rerequest, the requestor is added to the subscription list
		

	SessionOutputStream
		- All messages generated for a session are written to a SessionOutputStream
		- A sink for generated messages
		- Written messages are persisted before being written to the message bus
		
	Keeping up with a stream
		- a subscriber who's requests are not generating rerequests on the server and who is processing stream messages such that no queueing occurs on the server for the channel.


	Rewind
		- When a new request asks for 		 

Components:
Session
	- A logical grouping of data 
	- A current day's session may be subscribed to using a SessionRequest
	- A Session may be named according to a naming convention.
	- A Session is populated with messages by a message generating process.
	- The name of a Session is provided to the message generating process before 
	- A message generating process tags each generated message with a session identifier
	- Has a last sequence number representing the sequence number of the last message broadcast to Subscribers
	- A session is capable of being archived
	- A session may be served after it has been closed.k
	
SessionProvider
	- An event bus for session data
	
	
SessionStream
	- The realtime feed of messages being generated for the ActiveSession
	- A SessionPersistor saves 
	- Clients subscribe to the SessionStream

SessionServer
	- Serves messages for a configured SessionSource
	- Knows what the curhrent ActiveSession is
	- Receives requests for Session information
	- Knows whether or not a session request is valid 
	- Uses a SessionProvider to receive data
	- Listens for / polls for new session data.
	- Knows how to retrieve information for a given session
	- Reads data from a SessionInputSource

PersistentStore
	- 

SessionEndpoint


SessionInputSource
	- The source of data for a SessionServer
	- May be one of several different types (pollable, streaming
	

How is a session ended?
	By receiving an end of day message 
	
Who sends the end of day session?
	The SessionGenerator
	
			
SessionSink
	- Receives messages generated by a Generator
	- May persist messages
	- May queue messages in memory for consumption	
	

MessageGenerator 
	- Generates a message for an ActiveSession on demand 
	- Maintains a registry of MessageListeners
	- Broadcasts generated messages to registered MessageListeners

MessageGeneratorTask
	- Invokes a MessageGenerator
	
MessageListener
	- Invoked by a MessageGenerator on the arrival of new messages
	
How is a session created?
	- An identifier is established
	
How is a session identifier established?
	- Root token is the current date
	- Check for existence of other sessions on current date

What initiates a session?
	- The engine
	- The engine assumes the session is 




ActiveSession
	- A Session that is accepting new subscribers and receiving new data.
	- Associated with a Session
	
SessionRequest
	- Represents the session id and first sequence number that a client is requesting
	- May be interpretted by a SessionServer as either valid or invalid
	- If the requested session id is different from the SessionServer's ActiveSession, the SessionRequest is invalid.
	


SessionRerequest
	- Represents a SessionRequest by a specific client for "old" data, either previously broadcast from the current session or an old session

Subscription
	- Represents a client interested in receiving messages from an ActiveSession
	- Acts as a MessageListener
	- May be associated with a Rewind / Replay 
	- Messages received by a subscription with an active SessionRetransmission are queued until notified that said Rewind / Replay are complete

	
SessionRewind 
	- Rewind, replay and unicast transmission of ActiveSession data to a single subscriber
		
SessionPull
	- Retrieval of inactive session data and unicasting it to a single target

SessionHandler
	- Determines whether a SessionRequest for a newly created channel is for the current session or a previous session
	- If the SessionRequest is for prior session, the channel will not be added to the broadcast
	- If the SessionRequest is for the current session, the request will be added to the broadcast marked as retransmit
	

SessionRetransmission
	- Represents a unicast feed of data associated with a SessionRerequest
	- Associated with a single Subscription


SessionRoller
	- Creates a new session
	- 
	
Server
	- Maintains an ActiveSession
	- Broadcasts messages for an ActiveSession
	- Processes SessionPull requests 
	- Processes subscription requests
	- Maintains a SubscriptionList
	- 
	
SubscriptionList
	- Represents all active subscriptions of an ActiveSession
	- New 	
	
	
How do ChannelHandlers fit into the model?
Does a ChannelHandler cound as a component?
A ChannelHandler is a part of the Netty layered protocol architecture.
In Netty, each layer of the protocol stack handles some aspect of servicing either an inbound request or an outbound message.



In Inet, a session is just a container for messages generated during the day.
	Generated data is persisted before it is published (transactional)
	




Protocol
- Server listens on socket
- Client connects to server
- Server waits for login request
- Client sends login request
- Server processes login request
	- Request is a subscription request if:
		- no sessionid
		- sessionid equals ActiveSession id
	- Subscription request requires replay if firstSequenceNumber is < the ActiveSession's sequence number
	
	- On successfully processing a subscription request, do the following:
		- add Subscription to SubscriptionList, marking Subscription as requiring replay if applicable
		- if this is the first subscription to be added, register the subscription with the SubscriptionList and attach the SubscriptionList to the loader.
			
			- if the subscription requires a rewind
				- initiate a rewind request
				- buffer outbound broadcast messages until rewind is completed.
				- once rewind is completed, mark as completed 
				- write buffer
				- process broadcast as normal
			- if subscription doesn't require a rewind
				- 
	
	
	- Reject login request if not a subscription request
	
	
- Server 

Login message
L[sessionid][first sequencenum]

sessionid - S##
first sequencenum - 4 digit number, left padded with 0's




	
	
SessionRerequest

SessionRetransmissionListener
	- Notified when a retransmission has completed

Session retransmitter
	- 
	
	
	


Start Server
Server creates new channels for each new client connection
The server maintains a single MessageGenerator whose messages are sent to all active channels
The messageGenerator is a singleton
The messageGenerator is registered within a ChannelHandler that implements MessageListener
This ChannelHandler maintains a special ChannelGroup that implements MessageListener
When the first channel is created, the 
All channels are 
on receiving the first client connection, server registers the channel in a new ChannelGroup and registers the channel group with the MessageGenerator as a MessageListener
starts the message generator


The message generator 

multiple clients






Problem
Someone subscribes late.  How can he catch up and then join the subscription?

Not video, just data
Acquisition delay


rerequest server

cache certain amount of data
hit db, join group, cache multicast traffic while unicast transmission occurs, then release cached data

gather data, then acquire multicast lock, load gap from cache, join multicast group, then release multicast lock.


http://www.faqs.org/rfcs/rfc6285.html


